use crate::again;
use itertools::{self, Itertools};

fn group_lines(texts: Vec<again::Text>) -> Vec<Vec<again::Text>> {
    texts
        .iter()
        .group_by(|x| x.line_number)
        .into_iter()
        .map(|(_, x)| x.into_iter().map(|y| y.clone()).collect())
        .collect()
}

fn format_column(string: &str, column: i32) -> String {
    let n = column as usize;
    let binding = " ".repeat(n);
    let fstring = binding.as_str();
    format!("{}{}", fstring, string)
}

fn make_lists_equal_length(list1: Vec<char>, list2: Vec<char>) -> (Vec<char>, Vec<char>) {
    let (bigger_list, mut smaler_list) = if list1.len() > list2.len() {
        (list1, list2)
    } else if list1.len() < list2.len() {
        (list2, list1)
    } else {
        (list1, list2)
    };

    let padding = bigger_list.len() - smaler_list.len();
    let add_pad = vec![' '; padding];
    smaler_list.extend(add_pad.iter());

    let output = (bigger_list, smaler_list);
    output
}

pub fn overlay_2_str<'a>(str1: &'static str, str2: &'static str) -> String {
    let (bigger_str, smaler_str) = if str1.len() > str2.len() {
        (str1, str2)
    } else if str1.len() < str2.len() {
        (str2, str1)
    } else {
        (str1, str2)
    };

    let (bigger_list, smaler_list): (Vec<char>, Vec<char>) = make_lists_equal_length(
        bigger_str.chars().collect::<Vec<char>>(),
        smaler_str.chars().collect::<Vec<char>>(),
    );

    let mut output_list = bigger_list
        .iter()
        .zip(smaler_str.chars());


    String::from_iter(output_list)
}

fn overlay<'a>(lst: Vec<&str>) -> String {
    let mut last_element = lst[0].to_string();
    for i in 1..lst.len() {
        last_element = overlay_2_str(&last_element, lst[i]);
    }
    last_element.to_owned()
}
